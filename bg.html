<script>
    const CONFIG = {
      Gravity: 0.6,
      JumpForce: -12,
      BaseSpeed: 5,
      Speed: 5,
      MaxSpeed: 25,
      SpeedIncrement: 0.0015,
      GroundY: 340,
      SpawnRate: 100,
      NightThreshold: 500,
    };

    // --- VISUAL FX CLASSES ---

    class Particle {
      constructor(x, y, color, speed, size) {
        this.x = x;
        this.y = y;
        this.color = color;
        const angle = Math.random() * Math.PI * 2;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.life = 1.0;
        this.decay = Math.random() * 0.03 + 0.01;
        this.size = size;
      }
      Update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vy += 0.2; // Gravity for particles
        this.life -= this.decay;
      }
      Draw(ctx) {
        ctx.globalAlpha = Math.max(0, this.life);
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
      }
    }

    class Flower {
      constructor(canvasWidth) {
        this.x = canvasWidth + 10;
        this.y = CONFIG.GroundY; 
        this.stemHeight = Math.random() * 10 + 5;
        this.size = 0;
        this.maxSize = Math.random() * 4 + 2;
        this.color = `hsl(${Math.random() * 60 + 320}, 80%, 60%)`; // Pinks, Reds, Purples
        this.active = true;
      }
      Update() {
        this.x -= CONFIG.Speed;
        if (this.size < this.maxSize) this.size += 0.1; // Blooming effect
        if (this.x < -20) this.active = false;
      }
      Draw(ctx) {
        // Stem
        ctx.strokeStyle = "#558b2f";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(this.x, this.y - this.stemHeight);
        ctx.stroke();
        
        // Petals
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y - this.stemHeight, this.size, 0, Math.PI * 2);
        ctx.fill();
        
        // Center
        ctx.fillStyle = "white";
        ctx.beginPath();
        ctx.arc(this.x, this.y - this.stemHeight, this.size/2, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    class Star {
      constructor(w, h) {
        this.x = Math.random() * w;
        this.y = Math.random() * (h - 150); // Keep in sky
        this.size = Math.random() * 2;
        this.alpha = Math.random();
        this.twinkleSpeed = Math.random() * 0.02 + 0.005;
      }
      Update() {
        this.alpha += this.twinkleSpeed;
        if (this.alpha > 1 || this.alpha < 0.2) this.twinkleSpeed *= -1;
      }
      Draw(ctx, opacityMultiplier) {
        ctx.fillStyle = `rgba(255, 255, 255, ${this.alpha * opacityMultiplier})`;
        ctx.fillRect(this.x, this.y, this.size, this.size);
      }
    }

    class ShootingStar {
      constructor(w, h) {
        this.x = Math.random() * w + 200;
        this.y = Math.random() * 100;
        this.length = Math.random() * 80 + 20;
        this.speed = Math.random() * 10 + 10;
        this.active = true;
      }
      Update() {
        this.x -= this.speed;
        this.y += this.speed * 0.5;
        if (this.x < -100) this.active = false;
      }
      Draw(ctx) {
        let grad = ctx.createLinearGradient(this.x, this.y, this.x + this.length, this.y - (this.length * 0.5));
        grad.addColorStop(0, "rgba(255,255,255,1)");
        grad.addColorStop(1, "rgba(255,255,255,0)");
        ctx.strokeStyle = grad;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(this.x + this.length, this.y - (this.length * 0.5));
        ctx.stroke();
      }
    }

    // --- GAME CLASSES ---

    class Player {
      constructor() {
        this.width = 44;
        this.height = 47;
        this.x = 50;
        this.y = CONFIG.GroundY - this.height;
        this.velocityY = 0;
        this.isGrounded = true;
        this.legStep = 0;
      }
      Update() {
        this.velocityY += CONFIG.Gravity;
        this.y += this.velocityY;
        if (this.y > CONFIG.GroundY - this.height) {
          this.y = CONFIG.GroundY - this.height;
          this.velocityY = 0;
          this.isGrounded = true;
        } else {
          this.isGrounded = false;
        }
        if (this.isGrounded) this.legStep = Math.floor(Date.now() / 100) % 2;
        else this.legStep = 0;
      }
      Jump() {
        if (this.isGrounded) this.velocityY = CONFIG.JumpForce;
      }
      Draw(ctx, color) {
        ctx.fillStyle = color;
        const px = this.x;
        const py = this.y;
        // Simple Dino Shape
        ctx.fillRect(px + 22, py, 22, 18);
        ctx.fillRect(px + 18, py + 2, 4, 10);
        ctx.fillRect(px + 40, py + 2, 4, 10);
        // Eye (transparent)
        ctx.clearRect(px + 26, py + 4, 4, 4);
        
        ctx.fillRect(px, py + 18, 38, 16);
        ctx.fillRect(px, py + 14, 10, 4);
        ctx.fillRect(px + 36, py + 18, 4, 8);
        if (this.legStep === 0) {
          ctx.fillRect(px + 10, py + 34, 6, 8);
          ctx.fillRect(px + 10, py + 40, 10, 4);
          ctx.fillRect(px + 24, py + 34, 6, 4);
        } else {
          ctx.fillRect(px + 10, py + 34, 6, 4);
          ctx.fillRect(px + 24, py + 34, 6, 8);
          ctx.fillRect(px + 24, py + 40, 10, 4);
        }
      }
    }

    class Obstacle {
      constructor(x) {
        this.x = x;
        this.y = CONFIG.GroundY - 45;
        this.width = 25;
        this.height = 45;
        this.active = true;
      }
      Update() {
        this.x -= CONFIG.Speed;
        if (this.x + this.width < 0) this.active = false;
      }
      Draw(ctx, color) {
        if (!this.active) return;
        ctx.fillStyle = color;
        const ox = this.x;
        const oy = this.y;
        // Cactus shape
        ctx.fillRect(ox + 8, oy, 10, 45);
        ctx.fillRect(ox, oy + 10, 8, 5);
        ctx.fillRect(ox, oy + 10, 4, 15);
        ctx.fillRect(ox + 18, oy + 15, 8, 5);
        ctx.fillRect(ox + 22, oy + 15, 4, 15);
      }
    }

    class Asteroid {
      constructor(canvasWidth) {
        this.size = 60;
        this.x = Math.random() * (canvasWidth - this.size);
        this.y = -100;
        this.speed = 12;
        this.active = true;
        this.hasCrashed = false;
      }
      Update() {
        this.y += this.speed;
        if (this.y + this.size >= CONFIG.GroundY && !this.hasCrashed) {
          this.hasCrashed = true;
          this.active = false;
          return true; // Crash event
        }
        return false;
      }
      Draw(ctx) {
        if (!this.active) return;
        // Trail
        ctx.fillStyle = "rgba(255, 69, 0, 0.5)";
        ctx.fillRect(this.x + 10, this.y - 40, this.size - 20, 40);
        // Rock
        ctx.fillStyle = "#FF4500";
        ctx.fillRect(this.x, this.y, this.size, this.size);
      }
    }

    class Game {
      constructor() {
        this.canvas = document.getElementById("gameCanvas");
        this.ctx = this.canvas.getContext("2d");
        this.highScore = parseFloat(localStorage.getItem("dinoHighScore")) || 0;
        this.score = 0;
        this.frameCount = 0;
        this.isGameOver = false;
        this.obstacles = [];
        this.player = new Player();
        this.asteroid = null;
        this.shakeTimer = 0;

        // Visual FX Arrays
        this.flowers = [];
        this.particles = [];
        this.stars = [];
        this.shootingStars = [];
        
        // Initialize Stars
        for(let i=0; i<60; i++) {
          this.stars.push(new Star(this.canvas.width, this.canvas.height));
        }

        this.dayCycle = 0; // 0 to 1
        this.colors = { bgTop: "#87CEEB", bgBot: "#E0F7FA", fg: "#535353" };

        this.Restart();
        document.addEventListener("keydown", (e) => this.OnInput(e));
        this.Loop();
      }

      OnInput(e) {
        if (["Space", "ArrowUp", "KeyW"].includes(e.code)) {
          if (this.isGameOver) this.Restart();
          else this.player.Jump();
        }
      }

      Restart() {
        this.player = new Player();
        this.obstacles = [];
        this.flowers = [];
        this.particles = [];
        this.shootingStars = [];
        this.score = 0;
        this.frameCount = 0;
        this.isGameOver = false;
        CONFIG.Speed = CONFIG.BaseSpeed;
        this.UpdateEnvironment();
      }

      SpawnLogic() {
        if (this.frameCount % Math.floor(CONFIG.SpawnRate * (CONFIG.BaseSpeed / CONFIG.Speed)) === 0) {
          if (Math.random() > 0.4) {
            this.obstacles.push(new Obstacle(this.canvas.width + Math.random() * 300));
          }
        }
        
        // Flower Spawn (Only in day/morning)
        if (this.dayCycle > 0.3 && Math.random() < 0.05) {
             this.flowers.push(new Flower(this.canvas.width));
        }

        // Shooting Star Spawn (Only at night)
        if (this.dayCycle < 0.2 && Math.random() < 0.01) {
            this.shootingStars.push(new ShootingStar(this.canvas.width, this.canvas.height));
        }
      }

      CheckCollisions() {
        this.obstacles.forEach((obs) => {
          let padding = 8;
          if (
            this.player.x < obs.x + obs.width - padding &&
            this.player.x + this.player.width > obs.x + padding &&
            this.player.y < obs.y + obs.height - padding &&
            this.player.y + this.player.height > obs.y + padding
          ) {
            this.GameOver();
          }
        });
      }

      GameOver() {
        this.isGameOver = true;
        if (this.score > this.highScore) {
          this.highScore = Math.floor(this.score);
          localStorage.setItem("dinoHighScore", this.highScore);
        }
      }

      UpdateEnvironment() {
        // Calculate Day/Night Cycle (0 = Midnight, 0.5 = Noon, 1 = Midnight)
        // One full cycle every 1000 score
        const rawCycle = (this.score % 1000) / 1000;
        // Use Sin wave for smooth light transition: -1 to 1, mapped to brightness
        const brightness = Math.sin((rawCycle - 0.25) * 2 * Math.PI) * 0.5 + 0.5;
        this.dayCycle = brightness; // Store for logic

        // Interpolate Background Colors
        if (brightness < 0.3) {
            // Night
            this.colors.bgTop = "#0B1026"; 
            this.colors.bgBot = "#2B32B2";
            this.colors.fg = "#cfcfcf";
        } else if (brightness < 0.5) {
            // Morning/Evening
            this.colors.bgTop = "#FF7E5F";
            this.colors.bgBot = "#FEB47B";
            this.colors.fg = "#535353";
        } else {
            // Noon
            this.colors.bgTop = "#4FACFE";
            this.colors.bgBot = "#00F2FE";
            this.colors.fg = "#535353";
        }
      }

      Update() {
        if (this.isGameOver) return;
        this.frameCount++;
        this.score += 0.1;

        if (CONFIG.Speed < CONFIG.MaxSpeed) CONFIG.Speed += CONFIG.SpeedIncrement;

        this.UpdateEnvironment();

        this.player.Update();
        this.obstacles.forEach(obs => obs.Update());
        this.obstacles = this.obstacles.filter(obs => obs.active);
        
        // Update Visuals
        this.stars.forEach(s => s.Update());
        this.flowers.forEach(f => f.Update());
        this.flowers = this.flowers.filter(f => f.active);
        
        this.shootingStars.forEach(s => s.Update());
        this.shootingStars = this.shootingStars.filter(s => s.active);

        this.particles.forEach(p => p.Update());
        this.particles = this.particles.filter(p => p.life > 0);

        // Asteroid Logic
        if (!this.asteroid && Math.random() < 0.002) {
          this.asteroid = new Asteroid(this.canvas.width);
        }
        if (this.asteroid) {
          let didHit = this.asteroid.Update();
          if (didHit) {
            this.shakeTimer = 20;
            // EXPLOSION PARTICLES
            for(let i=0; i<30; i++) {
                this.particles.push(new Particle(
                    this.asteroid.x + 30, 
                    CONFIG.GroundY, 
                    `hsl(${Math.random()*40 + 10}, 100%, 50%)`, // Orange/Yellow
                    Math.random() * 6 + 2,
                    Math.random() * 4 + 2
                ));
            }
            this.asteroid = null;
          }
        }

        if (this.shakeTimer > 0) {
          let shiftX = Math.random() * 20 - 10;
          let shiftY = Math.random() * 20 - 10;
          this.canvas.style.transform = `translate(${shiftX}px, ${shiftY}px)`;
          this.shakeTimer--;
        } else {
          this.canvas.style.transform = "none";
        }

        this.SpawnLogic();
        this.CheckCollisions();
      }

      Draw() {
        // Draw Beautiful Gradient Background
        let grad = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
        grad.addColorStop(0, this.colors.bgTop);
        grad.addColorStop(1, this.colors.bgBot);
        this.ctx.fillStyle = grad;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Draw Stars (Only visible based on darkness)
        const starVisibility = Math.max(0, 1 - (this.dayCycle * 3)); // Fade out during day
        if (starVisibility > 0) {
            this.stars.forEach(s => s.Draw(this.ctx, starVisibility));
            this.shootingStars.forEach(s => s.Draw(this.ctx));
        }
        
        // Sun/Moon Icon
        this.ctx.font = "40px serif";
        let celestialX = 850 - ((this.score % 1000) / 1000) * 1000; 
        if(celestialX < -50) celestialX = 850;
        this.ctx.fillText(this.dayCycle < 0.3 ? "ðŸŒ™" : "â˜€ï¸", celestialX, 80);

        // Draw Flowers (Behind everything)
        this.flowers.forEach(f => f.Draw(this.ctx));

        // Ground Line
        this.ctx.strokeStyle = this.colors.fg;
        this.ctx.beginPath();
        this.ctx.moveTo(0, CONFIG.GroundY);
        this.ctx.lineTo(this.canvas.width, CONFIG.GroundY);
        this.ctx.lineWidth = 2;
        this.ctx.stroke();

        this.player.Draw(this.ctx, this.colors.fg);
        this.obstacles.forEach(obs => obs.Draw(this.ctx, this.colors.fg));
        if (this.asteroid) this.asteroid.Draw(this.ctx);
        
        // Particles (On top of everything)
        this.particles.forEach(p => p.Draw(this.ctx));

        // UI
        this.ctx.fillStyle = this.colors.fg;
        this.ctx.textAlign = "right";
        this.ctx.font = "20px Consolas";
        this.ctx.fillText(
          `HI ${Math.floor(this.highScore).toString().padStart(5, "0")}  ${Math.floor(this.score).toString().padStart(5, "0")}`,
          this.canvas.width - 20, 30
        );

        if (this.isGameOver) {
          this.ctx.fillStyle = "rgba(0,0,0,0.5)";
          this.ctx.fillRect(200, 150, 400, 100);
          this.ctx.fillStyle = "#FFF";
          this.ctx.textAlign = "center";
          this.ctx.font = "30px Consolas";
          this.ctx.fillText("G A M E  O V E R", this.canvas.width / 2, this.canvas.height / 2);
          this.ctx.font = "20px Consolas";
          this.ctx.fillText("Press Space to Restart", this.canvas.width / 2, this.canvas.height / 2 + 40);
        }
      }

      Loop() {
        this.Update();
        this.Draw();
        requestAnimationFrame(() => this.Loop());
      }
    }

    const app = new Game();
  </script>
